<html>
  <head>
	  <title>Method Definition - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Method Definition</div>
		</div>

    <div class="text">

	<p>Methods add functional behavior to a defined type, offering capabilities consistent with
		and helpful for values of that type.
		For example (as mentioned <a href="refexpr.html#method">earlier</a>), 
		<span class="pre">`+`</span> is one of several methods defined for the <span class="pre">i32</span> type.
		It adds two integers together and returns the result.</p>
	<p>Methods are pre-defined for the number types.
		However, for some custom-declared types, such as structs or enums, no default methods are provided.
		Instead, methods are defined in the same block as the data structure declarations.</p>
	<p>This example defines several methods as part of the <span class="pre">Point</span> declaration:</p>
<pre>
struct Point
  x f32
  y f32
		
  // Calculate distance between two points
  fn distance(pt2) f32
    (self-pt2).len

  // Subtract two points
  fn `-`(pt2) Point
    Point[pt2.x - x, pt2.y - y]

  // Calculate length of point
  fn len() f32
    _lensq().sqrt // _lensq() is equivalent to self._lensq()
	
  // A private method
  fn _lensq() f32
		x*x + y*y
</pre>
	<p>There's a lot to unpack here, which we will get to soon.
		The end result is that the above type definition for Point now makes
		it possible to write logic that uses these methods:
	</p>
<pre>
imm from = Point[x: 1., y: 1.]
imm to   = Point[x: 4., y: 5.]
imm dist = from.distance(to)     // == 5.0. Pythagoras would be proud
</pre>
	<p>Methods may be defined for named types, such as structs, enums, integers, and floating point.
		However, methods may not be defined for the array types, as they are unnamed.
		This restriction is easily remedied by wrapping an array in a named struct.</p>
	<p>In addition, the <span class="pre">extend</span> command may be used to add methods to an existing
		 type. For example:
		</p>
<pre>
extend i32
	fn double() Self
	  self+self
</pre>

	<h2>Method definition</h2>
	<p>A method definition looks (and behaves) like a function definition: It has a name, named parameter(s),
		return value type(s), and a statement body. 
		Let's examine how method definitions differ from functions.</p>

	<h3>Method name</h3>
	<p>As with fields, the names given to methods will not conflict with another type's method or field names,
		nor with the names of variables or functions outside the type.
		However, a type cannot have a method and field with the same name.</p>
	<p>Two or more methods <i>may</i> be given the same name.
		This is called <b>method overloading</b>.
		Each same-named method should be given a different parameter "signature":
		they should vary in number of parameters or in the types of the parameters.
		A call to a method of this name will be resolved by matching the method call's argument types
		to the defined methods' signatures.
		The method that matches best is used.
		Supporting multiple methods of the same name makes it convenient for a type to
		support a similar capability for a broad range of differently-typed values.</p>
	
	<h3 id="self">self Parameter</h3>
	<p>A method's first parameter is always named <span class="pre">self</span>.
		If a <span class="pre">self</span> parameter is not specified,
		one is inserted at the beginning of the parameter list.
		If the type of <span class="pre">self</span> is not specified,
		it is assumed to be the same as the type we are specifying (<span class="pre">Self</span>).
		If a type is specified for <span class="pre">self</span>, it must either be the same as <span class="pre">Self</span>,
		or some kind of reference to <span class="pre">Self</span>.

	<h3>Implicit parameter types</h3>
	<p>As with the <span class="pre">self</span> parameter,
	a method's other parameters need not specify their type.
	If omitted, <span class="pre">Self</span> is assumed.</p>

	<h3>Implicit field and method access</h3>
	<p>Nearly always, a method's logic needs access to the data object referred to by
			<span class="pre">self</span>. Often, it may also want to invoke other
			methods in the same type. As one would expect,
			such capabilities are easily achieved through the use of <span class="pre">self</span>:</p>
<pre>
imm len = (self.x * self.x + self.y * self.y).sqrt
self.clear()
</pre>
	<p>Fortunately, a more concise approach is possible, 
		by omitting "<span class="pre">self.</span>" altogether:</p>
<pre>
imm len = (x * x + y * y).sqrt
clear()
</pre>
	<p>Using the more concise syntax depends on not defining any local variables
		in the method that would conflict with the type's field or method names.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refmethop.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>